#!/usr/bin/env python3
"""
Generate the JSON schema for augur subsample configuration files.

This script creates the augur subsample configuration schema file with inline
comments for better maintainability.
"""

import json
import sys
import os
from pathlib import Path
from typing import Any, Dict

# Add augur package to Python path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))
from augur.filter.arguments import descriptions
from augur.subsample import SAMPLE_CONFIG, SAMPLE_PROXIMITY_CONFIG


OUTPUT = Path(__file__).parent.parent / "augur" / "data" / "schema-subsample-config.json"


def validate(schema_options: Dict[str, Any], config: Dict[str, Any]):
    schema_keys = set(schema_options.keys())
    config_keys = set(config.keys())

    if extra_in_schema := schema_keys - config_keys:
        raise Exception(f"Keys in schema but not in config: {sorted(extra_in_schema)}")

    if missing_in_schema := config_keys - schema_keys:
        raise Exception(f"Keys in config but not in schema: {sorted(missing_in_schema)}")

def _required_properties(options: Dict[str, Any]) -> Dict[str, Any]:
    """Extract properties marked with ``"required": True`` and return a dict
    with a ``"required"`` key suitable for unpacking into a JSON Schema object
    definition.  The ``"required"`` key is removed from each property in-place.
    """
    required = []
    for key, prop in options.items():
        if prop.pop("required", False):
            required.append(key)
    return {"required": required} if required else {}

def create_schema():
    # Initialize the schema with metadata.
    schema = {
        "_description": "This file is generated by devel/regenerate-subsample-schema. Do not edit manually - edit the script instead.",
        "$schema": "http://json-schema.org/draft-07/schema#",
        "$id": "https://nextstrain.org/schemas/augur/subsample-config/v1",
        "title": "Configuration file to be supplied to `augur subsample --config`",
        "type": "object",
        "additionalProperties": False,
        "required": ["samples"],
    }

    # Define default options that can be used at top-level or sample-level.
    default_options = {
        "exclude": {
            "oneOf": [
                {"type": "string", "format": "filepath"},
                {
                    "type": "array",
                    "items": {"type": "string", "format": "filepath"}
                }
            ],
            "description": descriptions["exclude"]
        },
        "exclude_all": {
            "type": "boolean",
            "description": descriptions["exclude_all"]
        },
        "exclude_ambiguous_dates_by": {
            "type": "string",
            "enum": ["any", "day", "month", "year"],
            "description": descriptions["exclude_ambiguous_dates_by"]
        },
        "exclude_where": {
            "oneOf": [
                {"type": "string"},
                {
                    "type": "array",
                    "items": {"type": "string"}
                }
            ],
            "description": descriptions["exclude_where"]
        },
        "include": {
            "oneOf": [
                {"type": "string", "format": "filepath"},
                {
                    "type": "array",
                    "items": {"type": "string", "format": "filepath"}
                }
            ],
            "description": descriptions["include"]
        },
        "include_where": {
            "oneOf": [
                {"type": "string"},
                {
                    "type": "array",
                    "items": {"type": "string"}
                }
            ],
            "description": descriptions["include_where"]
        },
        "min_date": {
            "type": ["string", "integer"],
            "description": descriptions["min_date"]
        },
        "max_date": {
            "type": ["string", "integer"],
            "description": descriptions["max_date"]
        },
        "min_length": {
            "type": "integer",
            "description": descriptions["min_length"]
        },
        "max_length": {
            "type": "integer",
            "description": descriptions["max_length"]
        },
        "non_nucleotide": {
            "type": "boolean",
            "description": descriptions["non_nucleotide"]
        },
        "query": {
            "type": "string",
            "description": descriptions["query"]
        },
        "query_columns": {
            "oneOf": [
                {"type": "string"},
                {
                    "type": "array",
                    "items": {"type": "string"}
                }
            ],
            "description": descriptions["query_columns"]
        }
    }

    # Define sample options as properties in the schema.
    # Note: these map directly to augur filter options¹, but that is an
    # implementation detail that may change in the future.
    # ¹ augur/subsample.py:SAMPLE_CONFIG
    sample_options = {
        **default_options,
        "target_sample": {
            "type": "string",
            "description": "Use the outputs from another sample as the inputs for this sample. Value must be a sample name.",
        },
        "drop_sample": {
            "type": "boolean",
            "description": "Drop this sample from the final output",
        },
        "group_by": {
            "oneOf": [
                {"type": "string"},
                {
                    "type": "array",
                    "items": {"type": "string"}
                }
            ],
            "description": descriptions["group_by"]
        },
        "group_by_weights": {
            "type": "string",
            "format": "filepath",
            "description": descriptions["group_by_weights"]
        },
        "probabilistic_sampling": {
            "type": "boolean",
            "description": descriptions["probabilistic_sampling"]
        },
        "sequences_per_group": {
            "type": "integer",
            "description": descriptions["sequences_per_group"]
        },
        "max_sequences": {
            "type": "integer",
            "description": descriptions["subsample_max_sequences"]
        }
    }

    validate(sample_options, SAMPLE_CONFIG)

    # Define sample proximity options as properties in the schema.
    # These map directly to augur proximity options¹.
    # ¹ augur/subsample.py:SAMPLE_PROXIMITY_CONFIG
    sample_proximity_options = {
        "method": {
            "type": "string",
            "enum": ["hamming"],
            # TODO XXX description - import from `augur proximity`
        },
        "query_sample": {
            "required": True,
            "type": "string",
            # TODO XXX - must be the _name_ of a sample, but don't think schema can check this...
            # TODO XXX description - import from `augur proximity`
        },
        "drop_sample": {
            "type": "boolean",
            "description": "Drop this sample from final outputs", # TODO XXX
        },
        "context_sample": {
            "type": "string",
            # TODO XXX - must be the _name_ of a sample, but don't think schema can check this...
            # TODO XXX if not set will use everything...
            # TODO XXX description - import from `augur proximity`
        },
        "k": {
            "type": "integer",
            # TODO XXX description - import from `augur proximity`
        },
        "max_distance": {
            "type": "integer",
            # TODO XXX description - import from `augur proximity`
        },
        "missing_data": {
            "type": "string",
            # TODO XXX description - import from `augur proximity`
        },
    }

    validate(sample_proximity_options, SAMPLE_PROXIMITY_CONFIG)

    # Add definitions for default and sample options.
    schema["$defs"] = {
        "defaultProperties": {
            "type": "object",
            "additionalProperties": False,
            "properties": default_options
        },
        "sampleProperties": {
            "type": "object",
            "additionalProperties": False,
            "properties": sample_options,
            **_required_properties(sample_options),
        },
        "sampleProximityProperties": {
            "type": "object",
            "additionalProperties": False,
            "properties": sample_proximity_options,
            **_required_properties(sample_proximity_options),
        }
    }

    # Define the schema structure.
    schema["properties"] = {
        "defaults": {"$ref": "#/$defs/defaultProperties"},
        "samples": {
            "type": "object",
            "minProperties": 1,
            "patternProperties": {
                # Sample names can be any non-empty string.
                "^.+$": {
                    "oneOf": [
                        {"$ref": "#/$defs/sampleProperties"},
                        {"$ref": "#/$defs/sampleProximityProperties"}
                    ]
                }
            }
        }
    }
    # Note: this leaves room for additional properties such as 'output' and
    # 'proximity_target' as briefly drafted in
    # <https://github.com/nextstrain/WNV/pull/97>.

    return schema


def main():
    # Generate the schema as a dictionary.
    schema = create_schema()

    # Write to the schema file.
    with open(OUTPUT, 'w') as f:
        json.dump(schema, f, indent=4)
    print(f"Schema generated successfully: {OUTPUT}")


if __name__ == "__main__":
    main()
