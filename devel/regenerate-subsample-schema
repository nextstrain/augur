#!/usr/bin/env python3
"""
Generate the JSON schema for augur subsample configuration files.

This script creates the augur subsample configuration schema file with inline
comments for better maintainability.
"""

import json
import sys
import os
from pathlib import Path
from typing import Any, Dict

# Add augur package to Python path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))
from augur.filter.arguments import descriptions
from augur.subsample import SAMPLE_CONFIG


OUTPUT = Path(__file__).parent.parent / "augur" / "data" / "schema-subsample-config.json"


def validate(sample_options: Dict[str, Any]):
    sample_option_keys = set(sample_options.keys())
    sample_config_keys = set(SAMPLE_CONFIG.keys())

    if extra_in_schema := sample_option_keys - sample_config_keys:
        raise Exception(f"Keys in sample_options but not in SAMPLE_CONFIG: {sorted(extra_in_schema)}")

    if missing_in_schema := sample_config_keys - sample_option_keys:
        raise Exception(f"Keys in SAMPLE_CONFIG but not in sample_options: {sorted(missing_in_schema)}")

def create_schema():
    # Initialize the schema with metadata.
    schema = {
        "_description": "This file is generated by devel/regenerate-subsample-schema. Do not edit manually - edit the script instead.",
        "$schema": "http://json-schema.org/draft-07/schema#",
        "$id": "https://nextstrain.org/schemas/augur/subsample-config/v1",
        "title": "Configuration file to be supplied to `augur subsample --config`",
        "type": "object",
        "additionalProperties": False,
        "required": ["samples"],
    }

    # Define default options that can be used at top-level or sample-level.
    default_options = {
        "exclude": {
            "oneOf": [
                {"type": "string", "format": "filepath"},
                {
                    "type": "array",
                    "items": {"type": "string", "format": "filepath"}
                }
            ],
            "description": descriptions["exclude"]
        },
        "exclude_all": {
            "type": "boolean",
            "description": descriptions["exclude_all"]
        },
        "exclude_ambiguous_dates_by": {
            "type": "string",
            "enum": ["any", "day", "month", "year"],
            "description": descriptions["exclude_ambiguous_dates_by"]
        },
        "exclude_where": {
            "oneOf": [
                {"type": "string"},
                {
                    "type": "array",
                    "items": {"type": "string"}
                }
            ],
            "description": descriptions["exclude_where"]
        },
        "include": {
            "oneOf": [
                {"type": "string", "format": "filepath"},
                {
                    "type": "array",
                    "items": {"type": "string", "format": "filepath"}
                }
            ],
            "description": descriptions["include"]
        },
        "include_where": {
            "oneOf": [
                {"type": "string"},
                {
                    "type": "array",
                    "items": {"type": "string"}
                }
            ],
            "description": descriptions["include_where"]
        },
        "min_date": {
            "type": ["string", "integer"],
            "description": descriptions["min_date"]
        },
        "max_date": {
            "type": ["string", "integer"],
            "description": descriptions["max_date"]
        },
        "min_length": {
            "type": "integer",
            "description": descriptions["min_length"]
        },
        "max_length": {
            "type": "integer",
            "description": descriptions["max_length"]
        },
        "non_nucleotide": {
            "type": "boolean",
            "description": descriptions["non_nucleotide"]
        },
        "query": {
            "type": "string",
            "description": descriptions["query"]
        },
        "query_columns": {
            "oneOf": [
                {"type": "string"},
                {
                    "type": "array",
                    "items": {"type": "string"}
                }
            ],
            "description": descriptions["query_columns"]
        }
    }

    # Define sample options as properties in the schema.
    # Note: these map directly to augur filter options¹, but that is an
    # implementation detail that may change in the future.
    # ¹ augur/subsample.py:SAMPLE_CONFIG
    sample_options = {
        **default_options,
        "target_sample": {
            "type": "string",
            "description": "Use the outputs from another sample as the inputs for this sample. Value must be a sample name.",
        },
        "drop_sample": {
            "type": "boolean",
            "description": "Drop this sample from the final output",
        },
        "group_by": {
            "oneOf": [
                {"type": "string"},
                {
                    "type": "array",
                    "items": {"type": "string"}
                }
            ],
            "description": descriptions["group_by"]
        },
        "group_by_weights": {
            "type": "string",
            "format": "filepath",
            "description": descriptions["group_by_weights"]
        },
        "probabilistic_sampling": {
            "type": "boolean",
            "description": descriptions["probabilistic_sampling"]
        },
        "sequences_per_group": {
            "type": "integer",
            "description": descriptions["sequences_per_group"]
        },
        "max_sequences": {
            "type": "integer",
            "description": descriptions["subsample_max_sequences"]
        }
    }

    validate(sample_options)

    # Add definitions for default and sample options.
    schema["$defs"] = {
        "defaultProperties": {
            "type": "object",
            "additionalProperties": False,
            "properties": default_options
        },
        "sampleProperties": {
            "type": "object",
            "additionalProperties": False,
            "properties": sample_options
        }
    }

    # Define the schema structure.
    schema["properties"] = {
        "defaults": {"$ref": "#/$defs/defaultProperties"},
        "samples": {
            "type": "object",
            "minProperties": 1,
            "patternProperties": {
                # Sample names can be any non-empty string.
                "^.+$": {"$ref": "#/$defs/sampleProperties"}
            }
        }
    }
    # Note: this leaves room for additional properties such as 'output' and
    # 'proximity_target' as briefly drafted in
    # <https://github.com/nextstrain/WNV/pull/97>.

    return schema


def main():
    # Generate the schema as a dictionary.
    schema = create_schema()

    # Write to the schema file.
    with open(OUTPUT, 'w') as f:
        json.dump(schema, f, indent=4)
    print(f"Schema generated successfully: {OUTPUT}")


if __name__ == "__main__":
    main()
