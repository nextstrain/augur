"""
Filter and subsample a sequence set.
"""
from augur.argparse_ import SKIP_AUTO_DEFAULT_IN_HELP
from augur.dates import numeric_date_type, SUPPORTED_DATE_HELP_TEXT
from augur.filter.io import ACCEPTED_TYPES, column_type_pair
from augur.io.metadata import DEFAULT_DELIMITERS, DEFAULT_ID_COLUMNS, METADATA_DATE_COLUMN
from augur.types import EmptyOutputReportingMethod
from . import constants


def register_arguments(parser):
    """
    Add arguments to parser.
    Kept as a separate function than `register_parser` to continue to support
    unit tests that use this function to create argparser.
    """
    input_group = parser.add_argument_group(
        title="Inputs",
        description="Metadata and sequences to be filtered.")
    input_group.add_argument('--metadata', required=True, metavar="FILE",
        help=f"Sequence metadata. {SKIP_AUTO_DEFAULT_IN_HELP}")
    input_group.add_argument('--sequences', '-s', metavar="FILE",
        help=f"Sequences in FASTA or VCF format. {SKIP_AUTO_DEFAULT_IN_HELP}")
    input_group.add_argument('--sequence-index', metavar="FILE",
        help=f"""Sequence composition report generated by augur index. If not
              provided, an index will be created on the fly.
              {SKIP_AUTO_DEFAULT_IN_HELP}""")
    input_group.add_argument('--metadata-chunk-size', type=int, metavar="N", default=100000,
        help="""Maximum number of metadata records to read into memory at a
             time. Increasing this number can speed up filtering at the cost of
             more memory used.""")
    input_group.add_argument('--metadata-id-columns', default=DEFAULT_ID_COLUMNS, nargs="+", metavar="COLUMN",
        help="""Names of possible metadata columns containing strain identifier
             information, ordered by priority. Only one ID column will be
             inferred.""")
    input_group.add_argument('--metadata-delimiters', default=DEFAULT_DELIMITERS, nargs="+", metavar="DELIMITER",
        help="""Delimiters to accept when reading a metadata file. Only one
             delimiter will be inferred.""")

    metadata_filter_group = parser.add_argument_group(
        title="Metadata filters",
        description="Filters to apply to metadata.")
    metadata_filter_group.add_argument('--query', metavar="QUERY",
        help=f"""Filter strains by attribute. Uses Pandas DataFrame querying, see
              https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#indexing-query
              for syntax. (e.g., --query "country == 'Colombia'" or --query
              "(country == 'USA' & (division == 'Washington'))")
              {SKIP_AUTO_DEFAULT_IN_HELP}"""
    )
    metadata_filter_group.add_argument('--query-columns', type=column_type_pair, nargs="+", metavar="COLUMN",
        help=f"""Use alongside --query to specify columns and data types in the
              format 'column:type', where type is one of
              {sorted(ACCEPTED_TYPES)}. Automatic type inference will be
              attempted on all unspecified columns used in the query. Example:
              region:str coverage:float. {SKIP_AUTO_DEFAULT_IN_HELP}""")
    metadata_filter_group.add_argument('--min-date', type=numeric_date_type, metavar="DATE",
        help=f"""Minimal cutoff for date, the cutoff date is inclusive; may be
              specified as: {SUPPORTED_DATE_HELP_TEXT}
              {SKIP_AUTO_DEFAULT_IN_HELP}""")
    metadata_filter_group.add_argument('--max-date', type=numeric_date_type, metavar="DATE",
        help=f"""Maximal cutoff for date, the cutoff date is inclusive; may be
              specified as: {SUPPORTED_DATE_HELP_TEXT}
              {SKIP_AUTO_DEFAULT_IN_HELP}""")
    metadata_filter_group.add_argument('--exclude-ambiguous-dates-by', choices=['any', 'day', 'month', 'year'], metavar="LEVEL",
        help=f"""Exclude ambiguous dates by day (e.g., 2020-09-XX), month (e.g.,
              2020-XX-XX), year (e.g., 200X-10-01), or any date fields. An
              ambiguous year makes the corresponding month and day ambiguous,
              too, even if those fields have unambiguous values (e.g.,
              "201X-10-01"). Similarly, an ambiguous month makes the
              corresponding day ambiguous (e.g., "2010-XX-01").
              {SKIP_AUTO_DEFAULT_IN_HELP}""")
    metadata_filter_group.add_argument('--exclude', type=str, nargs="+", metavar="FILE",
        help=f"""File(s) with list of strain IDs to exclude. The ID column is
             determined by --metadata-id-columns.
             {SKIP_AUTO_DEFAULT_IN_HELP}""")
    metadata_filter_group.add_argument('--exclude-where', nargs='+', metavar="CONDITION",
        help=f"""Exclude strains matching these conditions. Ex: \"host=rat\" or
              \"host!=rat\". Multiple values are processed as OR (matching any of
              those specified will be excluded), not AND. {SKIP_AUTO_DEFAULT_IN_HELP}""")
    metadata_filter_group.add_argument('--exclude-all', action="store_true",
        help=f"""Exclude all strains by default. Use this with the include
              arguments to select a specific subset of strains.
              {SKIP_AUTO_DEFAULT_IN_HELP}""")
    metadata_filter_group.add_argument('--include', type=str, nargs="+", metavar="FILE",
        help=f"""File(s) with list of strain IDs to include regardless of
              priorities, subsampling, or absence of an entry in --sequences.
              The ID column is determined by --metadata-id-columns.
              {SKIP_AUTO_DEFAULT_IN_HELP}""")
    metadata_filter_group.add_argument('--include-where', nargs='+', metavar="CONDITION",
        help=f"""Include strains with these values. ex: host=rat. Multiple
              values are processed as OR (having any of those specified will be
              included), not AND. This rule is applied last and ensures any
              strains matching these rules will be included regardless of
              priorities, subsampling, or absence of an entry in --sequences.
              {SKIP_AUTO_DEFAULT_IN_HELP}""")

    sequence_filter_group = parser.add_argument_group(
        title="Sequence filters",
        description="Filters to apply to sequence data.")
    sequence_filter_group.add_argument('--min-length', type=int, metavar="N",
        help=f"""Minimal length of the sequences, only counting standard
              nucleotide characters A, C, G, or T (case-insensitive).
              {SKIP_AUTO_DEFAULT_IN_HELP}""")
    sequence_filter_group.add_argument('--max-length', type=int, metavar="N",
        help=f"""Maximum length of the sequences, only counting standard
              nucleotide characters A, C, G, or T (case-insensitive).
              {SKIP_AUTO_DEFAULT_IN_HELP}""")
    sequence_filter_group.add_argument('--non-nucleotide', action='store_true',
        help=f"""Exclude sequences that contain illegal characters.
              {SKIP_AUTO_DEFAULT_IN_HELP}""")

    subsample_group = parser.add_argument_group(
        title="Subsampling",
        description="Options to subsample filtered data.")
    subsample_group.add_argument('--group-by', nargs='+', metavar="COLUMN",
        help=f"""Categories with respect to subsample. Notes:
        (1) Grouping by {sorted(constants.GROUP_BY_GENERATED_COLUMNS)} is only
            supported when there is a {METADATA_DATE_COLUMN!r} column in the
            metadata.
        (2) 'week' uses the ISO week numbering system, where a week starts on a
            Monday and ends on a Sunday.
        (3) 'month' and 'week' grouping cannot be used together.
        (4) Custom columns {sorted(constants.GROUP_BY_GENERATED_COLUMNS)} in the
            metadata are ignored for grouping. Please rename them if you want to
            use their values for grouping.
        {SKIP_AUTO_DEFAULT_IN_HELP}""")

    subsample_limits_group = subsample_group.add_mutually_exclusive_group()
    subsample_limits_group.add_argument('--sequences-per-group', type=int, metavar="N",
        help=f"""Subsample to no more than this number of strains per
              category. {SKIP_AUTO_DEFAULT_IN_HELP}""")
    subsample_limits_group.add_argument('--subsample-max-sequences', type=int, metavar="N",
        help=f"""Subsample to no more than this number of strains; can be used
              without --group-by. {SKIP_AUTO_DEFAULT_IN_HELP}""")

    probabilistic_sampling_group = subsample_group.add_mutually_exclusive_group()
    probabilistic_sampling_group.add_argument('--probabilistic-sampling', action='store_true',
        help="""Allow probabilistic sampling during subsampling. This is useful
             when there are more groups than requested strains. This option only
             applies when `--subsample-max-sequences` is provided.""")
    probabilistic_sampling_group.add_argument('--no-probabilistic-sampling', action='store_false', dest='probabilistic_sampling')

    subsample_group.add_argument('--priority', type=str, metavar="FILE",
        help=f"""Tab-delimited file with list of priority scores for strains
              (e.g., "<strain ID>\\t<priority>") and no header. When scores are
              provided, Augur converts scores to floating point values, sorts
              strains within each subsampling group from highest to lowest
              priority, and selects the top N strains per group where N is the
              calculated or requested number of strains per group. Higher
              numbers indicate higher priority. Since priorities represent
              relative values between strains, these values can be arbitrary.
              The ID column is determined by --metadata-id-columns.
              {SKIP_AUTO_DEFAULT_IN_HELP}""")
    subsample_group.add_argument('--subsample-seed', type=int, metavar="N",
        help=f"""Random number generator seed to allow reproducible subsampling
              (with same input data). {SKIP_AUTO_DEFAULT_IN_HELP}""")

    output_group = parser.add_argument_group(
        title="Outputs",
        description="""Options related to outputs. At least one of the possible
                    representations of filtered data (--output,
                    --output-metadata, --output-strains) is required.""")
    output_group.add_argument('--output', '--output-sequences', '-o', metavar="FILE",
        help=f"""Filtered sequences in FASTA format.
              {SKIP_AUTO_DEFAULT_IN_HELP}""")
    output_group.add_argument('--output-metadata', metavar="FILE",
        help=f"""Metadata for strains that passed filters.
              {SKIP_AUTO_DEFAULT_IN_HELP}""")
    output_group.add_argument('--output-strains', metavar="FILE",
        help=f"""List of strain IDs that passed filters (no header). The ID
              column is determined by --metadata-id-columns.
              {SKIP_AUTO_DEFAULT_IN_HELP}""")
    output_group.add_argument('--output-log', metavar="FILE",
        help=f"""Tab-delimited file with one row for each filtered strain and
              the reason it was filtered. Keyword arguments used for a given
              filter are reported in JSON format in a `kwargs` column.
              {SKIP_AUTO_DEFAULT_IN_HELP}""")
    output_group.add_argument('--empty-output-reporting',
        type=EmptyOutputReportingMethod.argtype,
        choices=list(EmptyOutputReportingMethod),
        default=EmptyOutputReportingMethod.ERROR,
        help="How should empty outputs be reported when no strains pass filtering and/or subsampling.")

    parser.set_defaults(probabilistic_sampling=True)


def register_parser(parent_subparsers):
    parser = parent_subparsers.add_parser("filter", help=__doc__)
    register_arguments(parser)
    return parser


def run(args):
    '''
    filter and subsample a set of sequences into an analysis set
    '''
    from .validate_arguments import validate_arguments
    # Validate arguments before attempting any I/O.
    validate_arguments(args)

    from ._run import run as _run
    return _run(args)
